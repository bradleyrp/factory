### REFERENCE

# Dockerfile components
dockerfiles:
  copy_run_script: |
    COPY script.sh script.sh
    CMD ["bash","script.sh"]
  stretch: |
    FROM debian:stretch
  debian_start: |
    ARG DEBIAN_FRONTEND=noninteractive
    RUN apt-get -y clean
    RUN apt-get -y update
    RUN apt-get install -y git make wget vim screen
    RUN apt-get install -y procps
    RUN apt-get install -y python python-dev
    ENV PYTHONIOENCODING UTF-8
  debian_mysql: |
    RUN apt-get install -y mysql-server default-libmysqlclient-dev
  debian_compilers: |
    RUN apt-get install -y cmake
    RUN apt-get install -y build-essential
    RUN apt-get install -y m4
    RUN apt-get install -y automake
    RUN apt-get install -y libtool
  debian_expose_ports: |
    EXPOSE 22
    EXPOSE 8000
    EXPOSE 8888
  debian_apache:
    RUN apt-get install -y apache2 apache2-dev
  debian_image_magick:
    RUN apt-get install -y imagemagick
  debian_shell_bash: |
    SHELL ["/bin/bash", "--login", "-c"]
  make_user:
    # formats for subs: key, val, python function, builtin function
    subs:
      user: user
      uid: 1000
      user_passwd: secret
      gid: 100
      gname: users
    text: |
      RUN getent group %(gid)s > /dev/null 2>&1 \
          || (groupmod -g %(gid)d %(gname)s)
      RUN useradd -m -u %(uid)d -g %(gid)d %(user)s
      RUN echo '%(user)s:%(user_passwd)s' | chpasswd
      USER %(user)s
      WORKDIR /home/%(user)s
  gromacs-2018.3: |
    WORKDIR /root
    RUN apt-get install -y libfftw3-dev
    RUN wget ftp://ftp.gromacs.org/pub/gromacs/gromacs-2018.3.tar.gz
    RUN tar xvf gromacs-2018.3.tar.gz
    WORKDIR /root/gromacs-2018.3
    RUN mkdir build
    WORKDIR /root/gromacs-2018.3/build
    RUN cmake /root/gromacs-2018.3
    RUN make -j 2
    RUN make install
    WORKDIR /root
  singularity: |
    WORKDIR /root
    RUN apt-get install -y squashfs-tools
    RUN apt-get install -y libarchive-dev
    RUN git clone https://github.com/singularityware/singularity.git
    WORKDIR /root/singularity
    RUN git checkout vault/release-2.6
    RUN ./autogen.sh
    RUN ./configure --prefix=/usr/local
    RUN make
    RUN make install

### macos utilities (see hooks/macdrive.py)
macos_unmount:
  call: hdiutil detach /Volumes/site-nix

### MINOR EXPERIMENTS

factory_notebook:
  via: deploy_linux_factory
  overrides:
    command: docker-compose up -d deploy
    script: |
      cd factory
      source env/bin/activate py3
      jupyter notebook --port=8888 --no-browser --ip=0.0.0.0 
factory_notebook_live:
  # run the notebook in the foreground
  via: deploy_linux_factory
  overrides:
    command: docker-compose run --service-ports deploy
    script: |
      cd factory
      source env/bin/activate py3
      jupyter notebook --port=8888 --no-browser --ip=0.0.0.0 

factory_build:
  # run the build script below to ensure factory exists without rebuilding image
  via: deploy_linux_factory
  overrides:
    command: docker-compose run deploy
factory_rebuild:
  # rebuild the container to accomodate changes
  via: deploy_linux_factory
  overrides:
    rebuild: true
factory_build_full:
  # an alternate (override) rebuild of the container with more software
  via: deploy_linux_factory
  overrides:
    rebuild: true
    dockerfile:
      sequence:
        - stretch
        - debian_start
        - debian_mysql
        - debian_shell_bash
        - debian_compilers
        - gromacs-2018.3
        - make_user
      addendum:
        #! hardcoded. needs shell substitution
        - WORKDIR /home/user/extern

### PRIMARY RECIPE BASE

deploy_linux_factory:
  # see factory_* recipes rather than using this directly
  # hook to check mounts if we must run in an external volume
  # "site" instructions
  #   the site tells this factory where (on disk) to deploy a dockerized factory
  #   on linux, run `make set_hook deploy_site=/path/to/deployment/site`
  #   on macos, read the docstring in get_macrdive in hooks/macdrive.py 
  #     to set up an external volume, which is required due to filename case
  site: "@deploy_site"
  # we assume that the site is a permanent spot for storing the "real" factory
  persist: true
  script: |
    if [ -d factory ]; then echo "[STATUS] factory already exists" && exit 0; fi
    # this script can repeat to confirm the installation
    git clone https://github.com/bradleyrp/factory factory
    cd factory
    git pull
    if [ ! -f Miniconda3-latest-Linux-x86_64.sh ]; then 
      wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh
      ln -s Miniconda3-latest-Linux-x86_64.sh miniconda.sh
    fi
    # bootstrap the config
    make
    # make the environment or update if reqs.yaml has changed
    make env conda_py3
  # note that if you want to build this, you should run factory_(re)build
  rebuild: false 
  dockerfile:
    sequence:
      - stretch
      - debian_start
      - debian_compilers
      - debian_mysql
      - debian_apache
      - debian_image_magick
      - debian_shell_bash
      - make_user
    addendum:
      # we use a generic "user" throughout
      - WORKDIR /home/user/extern
  compose:
    version: '3'
    services:
      visit:
        build: .
        image: factory:deploy_linux_factory
        volumes:
          - ./:/home/user/extern
        stdin_open: true
        tty: true
        command: ['/bin/bash']
        ports:
          - "8888:8888"
        container_name: factory_visit
      deploy:
        entrypoint: ['/bin/bash','script.sh']
        build: .
        image: factory:deploy_linux_factory
        volumes:
          - ./:/home/user/extern
        ports:
          - "8888:8888"
        hostname: factory_remote
        container_name: factory_deploy
  command: docker-compose up -d deploy

### PRIMARY USER RECIPES

factory_up:
  via: deploy_linux_factory
  overrides:
    command: docker-compose up -d site
    compose:
      version: '3'
      services:
        site:
          build: .
          image: factory:deploy_linux_factory
          stdin_open: true
          tty: true
          container_name: factory_site
          entrypoint: ['/bin/bash','script.sh']
          # add volumes if running a connection
          volumes:
            - ./:/home/user/extern
    script: |
      cd factory
      rm -f pid* TASK_QUEUE
      # make connection goes here
      # note that factory_up should be used with via/mods to connect a project

factory_visit:
  via: factory_up
  mods:
    command: docker-compose run --service-ports site
    compose:
      services:
        site:
          entrypoint: ['/bin/bash']

### CONNECTIONS

factory_actinlink_up:
  via: factory_up
  mods:
    compose: 
      services:
        site:
          # volumes exposes the connection file
          volumes:
            - ./:/home/user/extern
            - /Users/rpb/worker/factory/connections/actinlink.yaml:/home/user/extern/factory/connections/actinlink.yaml
            - /Users/rpb/worker/post-factory-demo:/home/user/worker/post-factory-demo
          # host:container, must match connection file
          ports: 
            - "9000:8000"
            - "9001:8001"
  overrides:
    script: |
      cd factory
      rm -f pid* TASK_QUEUE
      make connect actinlink_container
      make run actinlink_container public
      sleep infinity
